<!DOCTYPE html>
<head>
<meta charset="utf-8">

<script src="jquery-3.1.0.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="../graph.json"></script>
</head>

<body>
<svg width="960" height="900"></svg>

<script>

graph.nodes.forEach(function(d){
    d.height = 20;
    d.width = Math.min(100, d.value.length*8 +2);

});


var svg = d3.select("svg");

var width = +svg.attr("width"),
    height = +svg.attr("height");



function node_color(node){
  var maper = {
    "machine_name":d3.schemeCategory20[1],
    "ip":d3.schemeCategory20[3],
    "user_name":d3.schemeCategory20[5],
    "user_id":d3.schemeCategory20[7]
  }
  if(node.type in maper){
    return maper[node.type];
  }
  else{
    return d3.color("orange");
  }
}

function link_distance(link){
  var maper = {
    "has":20,
    "is":5,
    "access":100,
  }
  if(link.type in maper){
    return maper[link.type];
  }
  else{
    return 200;
  }
}
 function link_color(link){
  var maper = {
    "is":d3.color("red"),
    "has":d3.color("blue"),
    "access":d3.color("green"),
  }
  if(link.type in maper){
    return maper[link.type];
  }
  else{
    return d3.color("orange");
  }

 }

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink()
                     .id(function(d) { return d.id; })
                     .distance(function (d)  {return link_distance(d);}))
//                     .strength(function (link){
  //                     return link_strength(link);
    //                  }))
    .force("charge", d3.forceManyBody()
                       .strength(-150))
    .force("center", d3.forceCenter(width / 2, height / 2));



var links = svg.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
      .attr("stroke",link_color)
      .attr("stroke-opacity",0.5)
      .attr("stroke-width", function(d) { return 2; })
      .on("mouseover",function(d){console.log(d);});

var gnodes = svg.selectAll(".node")
    .data(graph.nodes)
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

var nodes = gnodes.append("rect")
    .attr("width", function(d){return d.width;}) //TODO getComputedTextLength()
    .attr("height", function(d){return d.height;})
    .style("opacity",0.5)
    .style("fill", node_color)
    .on("mouseover",function(d){console.log(d);});

var texts = gnodes.append("text")
      .style("font-size","12px")
      .text(function(d) { return d.value.slice(0,12); }) //todo three dots
      .style("fill","black");
//Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements


simulation
    .nodes(graph.nodes)
    .on("tick", ticked);

simulation.force("link")
    .links(graph.links);

function ticked() {
  var i = 0,
      n = graph.nodes.length;
  var q = d3.quadtree()
    .x(function(d){return d.x;})
    .y(function(d){return d.y;})
    .addAll(graph.nodes);
  while (++i < n) {
    q.visit(collide(graph.nodes[i]));
  }

  links
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });


  nodes
    .attr("x", function (d) { return d.x;})
    .attr("y", function (d) { return d.y;});

  texts
    .attr("x", function (d) { return d.x;})
    .attr("y", function (d) { return d.y+15;});

}

function collide(node) {
  return function(tree, x1, y1, x2, y2) {
    var nx1 = node.x,
        ny1 = node.y,
        nx2 = node.x+node.width,
        ny2 = node.y+node.height;
    var left = Math.min(x1,nx1,x2,nx2),
        right =  Math.max(x1,nx1,x2,nx2),
        up =  Math.min(y1,ny1,y2,ny2),
        down =  Math.max(y1,ny1,y2,ny2);
    var xPadding = 5,
        yPadding = 2;
    var xSize = (x2-x1) + (nx2-nx1) + xPadding,
        ySize = (y2-y1) + (ny2-ny1) + yPadding;

    if( right - left < xSize && down-up < ySize ){
      if ("data" in tree && (tree.data !== node)) {
        var point = tree.data;
        var x = node.x - point.x,
          y = node.y - point.y,
          xSpacing = (point.width + node.width) / 2 + xPadding,
          ySpacing = (point.height + node.height) / 2 + yPadding,
          absX = Math.abs(x),
          absY = Math.abs(y),
          l,
          lx,
          ly;

        if (absX < xSpacing && absY < ySpacing) {
          l = Math.sqrt(x * x + y * y);

          lx = (absX - xSpacing) / l;
          ly = (absY - ySpacing) / l;

          // the one that's barely within the bounds probably triggered the collision
          if (Math.abs(lx) > Math.abs(ly) ) {
            lx = 0;
          } else {
            ly = 0;
          }

          node.x -= x *= lx;
          node.y -= y *= ly;
          point.x += x;
          point.y += y;

          return true;
        }
      }
      return false;
    }
    else{
      return true;
    }

  };
}



function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}


</script>
</body>